# you-draw-i-guess
你画我猜游戏


> 项目未完。。。



## 学习总结

### 性能问题

画板部分，如果只是单纯的画画，是没有卡顿现象的。可是由于画画人所画的图片是需要实时性传输的，所以程序编写完后就出现了很严重的问题，我本来心里预期是卡顿，可没想到不是卡顿，是压根传送不了数据。

分析过程：

- 解决这个问题，我第一想到的就是节流函数，可是发现在使用节流函数后还是依然没有任何起色。所以，接下来就开始从函数实现方法开始着手。
- 我本来是通过在```touchmove```事件中调用```getImageData```方法来获取canvas图像，然后传输给后台，通过websorket分发数据。通过后台输出看到传输的`imageData`数据很大，后台是一部分一部分的接收的，根本毫无实时性可言。
- 于是排除使用```getImageData```方法，改为使用```toDataURL```的方法，这样获得的就是图片的base64编码字符串，体积会比```getImageData```得到的数据小得多，果然这样改完之后图片就开始传输了，只是传输过程有些卡顿现像。
- 加上节流函数，效果好了一些，但还是会卡。特别是越画到后面越卡，分析了一下，因为越画到后面，canvas画布内容越多，传输的base64编码越大，传输的就越慢。
- 于是想到每次传输只传画的那一笔，改为增量传输画面，这样就必须使用两层canvas。每次画的时候，画在前面一层canvas上，画的时候时时传输，然后这一笔画完之后，即触发了```touchend```的时候，将前面一层的canvas画面画到后面一层canvas上，将前面一层canvas画面清空，这样就能保证前面一层canvas每次都只有画一笔的过程，通过websocket将这一笔的过程传输到其他用户上面。然后每次触发```touchend```的时候通知其他用户，将这笔保存下来，后面接下来传来的第二笔画的过程要叠加上去，这样就保证了其他用户能看到完整的画面，而不是每次看到一笔的画面。果不其然，卡顿现象基本上没有了！

### 游戏运行中的逻辑关系

这个你画我猜的游戏，我是上网查了一些UI样式，然后脑子里面构想了一下，就开始编写了，开始写的很溜，可是越到后来就越乱了，因为这个游戏看起来规则很简单，但是如果写代码之前不把这些规则逻辑一条一条的理清楚的话，程序会一团糟。所以凡是编写一些稍微存在一些交互逻辑的东西，都得先理清楚，写下来。

1. 每个用户登录的时候，分配个他们每一个人一个独一无二的用户对象；（分析如何设计这个用户对象，对象中得有哪些必要的属性）
2. 只有房主能开始游戏，并且至少得存在两人。
3. 游戏开始后，就开始倒计时。
4. 游戏中途有人退出，如果是退出的人正在画画，那么必须等到时间结束才能换到下一个，退出后在进入可以接着画，倒计时时间也是必须得接上。（用户掉线后，再次登录，怎么判断这个登录的用户是上一个掉线的用户，重新登录后的用户怎么获取以前画的画面和倒计时的时间）

> 关于倒计时时间，一开始是放在前端处理，每次开始倒计时的时候把开始时间放在localStorage保存一下，在处理用户掉线后重新登录，就可以从localStorage中获取倒计时的时间，这样就可以衔接上。后来发现不对，因为如果是在本轮结束之前，这样做还好，如果进入了另外一个人的游戏时间呢，那么存储的时间就对不上了，所以就不能通过localStorage了，需要向后台传递开始时间，然后重新登陆后，再从后台获取。


### node.js调试知识

在chrome上调试node.js：

	npm install -g node-inspector	

	node-inspector	// 开启后不要关闭

	node --debug-brk index.js 	// 开启后不要关闭

按照提示打开本地地址即可。
